=== Start of File: jest.config.json ===
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "testMatch": [
    "**/?(*.)+(spec|test).[jt]s?(x)",
    "**/?(*.)+e2e-spec.ts?(x)"
  ],
  "transform": {
    "^.+\\.(ts|tsx)$": "ts-jest"
  },
  "moduleNameMapper": {
    "^@/(.*)$": "<rootDir>/src/$1",
    "\\.(css|less|scss|sass)$": "identity-obj-proxy"
  },
  "setupFilesAfterEnv": [
    "<rootDir>/jest.setup.ts"
  ],
  "collectCoverage": true,
  "collectCoverageFrom": [
    "src/**/*.{ts,tsx}",
    "!src/**/*.d.ts",
    "!src/main.ts",
    "!src/**/*.module.ts"
  ]
}
=== End of File: jest.config.json ===

=== Start of File: jest.setup.ts ===
// jest.setup.ts
// import '@testing-library/jest-dom/extend-expect';

=== End of File: jest.setup.ts ===

=== Start of File: nest-cli.json ===
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}
=== End of File: nest-cli.json ===

=== Start of File: next.config.js ===
// next.config.js
module.exports = {
  reactStrictMode: true,
  webpack: (config) => {
    // Exclude @mui and @emotion from being transpiled by SWC
    config.module.rules.forEach((rule) => {
      if (rule && rule.use && rule.use.loader === 'next-swc-loader') {
        rule.exclude = rule.exclude || [];
        rule.exclude.push(/node_modules\/@mui\/.*/);
        rule.exclude.push(/node_modules\/@emotion\/.*/);
      }
    });

    // Add a rule to transpile @mui and @emotion with Babel
    config.module.rules.push({
      test: /\.(js|jsx|ts|tsx)$/,
      include: [
        /node_modules\/@mui\/.*/,
        /node_modules\/@emotion\/.*/,
      ],
      use: {
        loader: 'babel-loader',
        options: {
          presets: ['next/babel'],
        },
      },
    });

    return config;
  },
};

=== End of File: next.config.js ===

=== Start of File: nodemon.json ===
{
    "watch": ["src"],
    "ignore": [".next/*", "node_modules/*", "dist/*"],
    "ext": "ts,tsx",
    "exec": "ts-node --project tsconfig.server.json src/main.ts"
  }
  
=== End of File: nodemon.json ===

=== Start of File: package.json ===
{
  "name": "your-project",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "dev": "node start-dev.js",
    "build": "tsc -p tsconfig.build.json && next build",
    "start": "node dist/main.js",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,css,md}\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@emotion/cache": "^11.13.1",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^6.1.1",
    "@mui/material": "^6.1.1",
    "@mui/material-nextjs": "^6.1.1",
    "@mui/system": "^6.1.1",
    "@mui/x-charts": "^7.18.0",
    "@mui/x-data-grid": "^7.18.0",
    "@mui/x-date-pickers": "^7.18.0",
    "@mui/x-tree-view": "^7.18.0",
    "@nestjs/common": "^10.4.1",
    "@nestjs/core": "^10.4.1",
    "@nestjs/platform-express": "^10.0.0",
    "@react-spring/web": "^9.7.4",
    "babel-loader": "^9.2.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.5",
    "helmet": "^7.1.0",
    "next": "^14.2.10",
    "prisma": "^5.19.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "tree-kill": "^1.2.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.10.0",
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^16.0.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.13",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.5.0",
    "@typescript-eslint/parser": "^8.5.0",
    "autoprefixer": "^10.4.20",
    "chokidar": "^3.5.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "eslint": "^8",
    "eslint-config-next": "^14.2.11",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-jsx-a11y": "^6.10.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react": "^7.36.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-unused-imports": "^4.1.4",
    "globals": "^15.9.0",
    "jest": "^29.7.0",
    "nodemon": "^3.1.4",
    "postcss": "^8.4.47",
    "prettier": "^3.3.3",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "tsconfig-paths": "^4.2.0",
    "typescript": "5.4.3",
    "typescript-eslint": "^8.5.0"
  }
}

=== End of File: package.json ===

=== Start of File: src/app.controller.ts ===
// src/app.controller.ts
import { Controller, Get } from '@nestjs/common';

@Controller()
export class AppController {
  @Get('hello')
  getHello() {
    return { message: 'Hello from NestJS API!' };
  }
}

=== End of File: src/app.controller.ts ===

=== Start of File: src/app.middleware.ts ===
import { Injectable, Logger, NestMiddleware } from '@nestjs/common';
import { NextFunction, Request, Response } from 'express';

@Injectable()
export class AppMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction): void {
    const start = Date.now();

    // Log requests
    res.on('finish', () => {
      const responseTime = Date.now() - start;
      const message = `${req.method} ${req.originalUrl} ${res.statusCode} ${
        res.get('Content-Length') || 0
      } - ${responseTime}`;

      // Log the request
      this.logger.log(message);
    });

    // Loosen CSP for Swagger routes
    if (
      req.path.startsWith('/swagger') ||
      req.path.startsWith('/favicon.ico')
    ) {
      res.setHeader(
        'Content-Security-Policy',
        "default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;",
      );
    }

    next();
  }
}

=== End of File: src/app.middleware.ts ===

=== Start of File: src/app.module.ts ===
// src/app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
  providers: [],
})
export class AppModule {}

=== End of File: src/app.module.ts ===

=== Start of File: src/app.service.ts ===
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

=== End of File: src/app.service.ts ===

=== Start of File: src/main.ts ===
// src/main.ts
import 'reflect-metadata';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { NextFunction, Request, Response } from 'express';
import Next from 'next';

import { AppModule } from './app.module';
import configApp from './config/config.app';
import configSecurityPolicy from './config/config.security';
// import configSwagger from './config/config.swagger';
import * as nextConfig from '../next.config.js';

NestFactory.create<NestExpressApplication>(AppModule).then(async (app) => {
  // Setup Next.js
  const dev = process.env.NODE_ENV !== 'production';
  const nextApp = Next({ dev, conf: nextConfig, dir: './',  });
  const handle = nextApp.getRequestHandler();
  await nextApp.prepare();

  // Set global prefix for API routes
  app.setGlobalPrefix('api');

  // Middleware to handle Next.js routing
  app.use((req: Request, res: Response, next: NextFunction) => {
    if (req.url.startsWith('/api')) {
      return next();
    }
    return handle(req, res);
  });

  // Config App
  const listen = configApp(app);

  // Config Security Policy
  configSecurityPolicy(app);

  // Config Swagger
  // configSwagger(app);

  // Listen for connections
  listen().then(() => {
    console.log(`> Ready on http://localhost:3000`);
  });
});

=== End of File: src/main.ts ===

=== Start of File: src/tsconfig.json ===
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "incremental": true,
    "module": "esnext",
    "esModuleInterop": true,
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}

=== End of File: src/tsconfig.json ===

=== Start of File: start-dev.js ===
const chokidar = require('chokidar');
const { spawn } = require('child_process');
const kill = require('tree-kill');
const readline = require('readline');

// Array to store all running processes
let processes = [];

// Set to store all active promises
const activePromises = new Set();

// Create a readline interface
readline.emitKeypressEvents(process.stdin);
process.stdin.setRawMode(true);

// Prevent Ctrl+C from sending SIGINT to the process
process.stdin.on('keypress', (str, key) => {
  if (key.ctrl && key.name === 'c') {
    // console.log('Ctrl+C was pressed, but it is disabled.');
    shutdown();
  }
});

// Helper function to track promises
function trackPromise(promise) {
  if (!promise || typeof promise.finally !== 'function') {
      throw new Error('trackPromise expects a Promise as an argument.');
  }
  activePromises.add(promise);
  promise.finally(() => activePromises.delete(promise));
  return promise;
}

// Helper function to spawn a child process
function spawnProcess(command, args, options = {}) {
  return trackPromise(new Promise((resolve, reject) => {
    let childProcess = spawn(command, args, {
      stdio: 'inherit',
      ...options,
    });
    processes.push(childProcess);

    childProcess.on('close', (code, signal) => {
      // Remove the child process from the list of running processes
      processes = processes.filter((p) => p !== childProcess);
      resolve(code, signal);
    });

    childProcess.on('error', (err) => {
      reject(err);
    });
  }));
}

// Initialize watcher.
const watcher = chokidar.watch('./src', {
  persistent: true,
  ignoreInitial: true,
  usePolling: true,  // Use polling for better cross-platform support, particularly on network file systems or Docker containers
});

// Helper function to compile the app
async function compile() {
  return trackPromise(spawnProcess('tsc', ['--project', 'tsconfig.server.json', '--outDir', '.nest']));
}

async function startServer() {
  return await trackPromise(spawnProcess('node', ['.nest/src/main.js']));
}

// Start the app
async function startApp() {
  try {
    await compile();
    await startServer()
  } catch (error) {
    console.error('Error during app execution:', error.message);
  }
}

async function killProcesses() {
  // Filter out processes that have already been killed
  processes = processes.filter((proc) => !proc.killed);

  // Kill each process gracefully with SIGTERM
  await Promise.all(
    processes.map((childProcess) =>
      new Promise((resolve) => {
        // console.log(`Killing process ${childProcess.pid}`);
        kill(childProcess.pid, 'SIGTERM', (err) => {
          if (err) {
            console.error(`Error killing process ${childProcess.pid}:`, err);
          }
          resolve(true);
        });
      })
    )
  );

  // Wait for 500ms to allow graceful shutdown
  await new Promise((resolve) => setTimeout(resolve, 500));

  // New processes array with only the processes that are still running
  processes = processes.filter((proc) => !proc.killed);

  // Force kill any remaining processes
  await Promise.all(
    processes.map((childProcess) =>
      new Promise((resolve) => {
        // console.log(`Force killing process ${childProcess.pid}`);
        kill(childProcess.pid, 'SIGKILL', (err) => {
          if (err) {
            console.error(`Error force killing process ${childProcess.pid}:`, err);
          }
          resolve(true);
        });
      })
    )
  );
}

let shuttingDown = false;
async function shutdown() {
  if (!shuttingDown) {
    shuttingDown = true;
    console.log('\nShutting down...');

    // Close the watcher
    watcher.close();

    // Kill all running processes
    await killProcesses();
  }

  // Check if all processes have been killed
  if (processes.length > 0) {
    // Wait for 500ms to allow graceful shutdown
    await new Promise((resolve) => setTimeout(resolve, 500));

    // Filter out processes that have already been killed
    processes = processes.filter((proc) => !proc.killed);
    if (processes.length > 0) {
      console.error('Unable to kill the following processes:', processes.map((proc) => proc.pid).join(', '));
      // process.exit(1);
    }
  }

  // Wait for all tracked promises to finish before exiting
  await Promise.all(Array.from(activePromises));

  // Stop reading from stdin
  // process.stdin.setRawMode(false); // TTY mode
  process.stdin.pause();

  // 100ms delay to allow console output to complete
  await new Promise((resolve) => setTimeout(resolve, 100));
}

process.on('SIGINT', async () => { 
  await shutdown();

  // Exit the process
  process.exit();
});

// Event listeners for when files change
watcher.on('change', async (path) => {
  console.log(`${path} has been changed. Restarting app...`);

  // Kill all running processes
  await killProcesses();

  // Clear out old processes
  processes = [];

  // Start the app again
  startApp();
});

watcher.on('error', (error) => console.error(`Watcher error: ${error}`));

(async function main() {
  // Start the app
  console.log('Starting app...');
  try {
    await trackPromise(startApp())
  } catch (error) {
    console.error('Error starting app:', error.message);
  }
})();
process.stdin.resume(); // Keep the process alive
=== End of File: start-dev.js ===

=== Start of File: tsconfig.build.json ===
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "ES2020",
    "declaration": true,
    "noEmit": false,
    "removeComments": true
  },
  "include": [
    "src/**/*"
  ],    
  "exclude": [
    "node_modules",
    "test",
    "**/*spec.ts",
    "**/*.test.ts",
    ".next",
    "pages",
    "app"
  ]
}

=== End of File: tsconfig.build.json ===

=== Start of File: tsconfig.json ===
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "forceConsistentCasingInFileNames": true,
    "jsx": "preserve",
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "allowSyntheticDefaultImports": true,
    "useDefineForClassFields": false,
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

=== End of File: tsconfig.json ===

=== Start of File: tsconfig.server.json ===
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "moduleResolution": "node",
    "noEmit": false,
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    ".next"
  ]
}
=== End of File: tsconfig.server.json ===
