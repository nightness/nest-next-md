
=== Start of File: jest.config.json ===
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "testMatch": [
    "**/?(*.)+(spec|test).[jt]s?(x)",
    "**/?(*.)+e2e-spec.ts?(x)"
  ],
  "transform": {
    "^.+\\.(ts|tsx)$": "ts-jest"
  },
  "moduleNameMapper": {
    "^@/(.*)$": "<rootDir>/src/$1",
    "\\.(css|less|scss|sass)$": "identity-obj-proxy"
  },
  "setupFilesAfterEnv": [
    "<rootDir>/jest.setup.ts"
  ],
  "collectCoverage": true,
  "collectCoverageFrom": [
    "src/**/*.{ts,tsx}",
    "!src/**/*.d.ts",
    "!src/main.ts",
    "!src/**/*.module.ts"
  ]
}
=== End of File: jest.config.json ===

=== Start of File: jest.setup.ts ===
// jest.setup.ts
// import '@testing-library/jest-dom/extend-expect';

=== End of File: jest.setup.ts ===

=== Start of File: nest-cli.json ===
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}
=== End of File: nest-cli.json ===

=== Start of File: next.config.js ===
// next.config.js
const withPWA = require('next-pwa')({
  dest: 'public',
  disable: process.env.NODE_ENV !== 'production',
  runtimeCaching: [
    {
      urlPattern: /^\/api\/.*$/,
      handler: 'NetworkOnly',
    },
    {
      urlPattern: /^\/swagger\/.*$/,
      handler: 'NetworkOnly',
    },
    {
      urlPattern: /^\/css\/.*$/,
      handler: 'NetworkOnly',
    },
    // Add other caching rules here if necessary
  ],
});

// next.config.js
module.exports = withPWA({
  reactStrictMode: true,
  // webpack: (config) => {
  //   return config;
  // },
});
=== End of File: next.config.js ===

=== Start of File: package.json ===
{
  "name": "your-project",
  "version": "0.0.0",
  "description": "",
  "author": "",
  "private": true,
  "license": "MIT",
  "scripts": {
    "dev": "node start-hybrid.js --watch",
    "dev:nest": "nest start --watch",
    "dev:next": "next dev",
    "build": "rm -rf .nest .next && nest build -p tsconfig.build.json && next build",
    "start": "node start-hybrid.js",
    "start:nest": "nest start",
    "start:next": "next start",
    "clean": "rm -rf .next .nest",
    "purge": "rm -rf node_modules .next .nest yarn.lock package-lock.json pnpm-lock.yaml",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,css,md}\"",
    "postinstall": "npx prisma generate",
    "prisma:generate": "npx prisma generate",
    "prisma:push": "npx prisma db push",
    "prisma:studio": "npx prisma studio",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "docker:build": "docker build -t your-nestjs-app .",
    "docker:clean": "docker system prune -af",
    "docker:down": "docker-compose down",
    "docker:logs": "docker-compose logs -f",
    "docker:migrate": "docker exec -it $(docker ps -qf \"name=your-container-name\") npm run migrate",
    "docker:rebuild": "docker-compose up -d --build",
    "docker:restart": "docker-compose down && docker-compose up --build",
    "docker:shell": "docker exec -it $(docker ps -qf \"name=your-container-name\") /bin/sh",
    "docker:start": "docker-compose up --build",
    "docker:up": "docker-compose up -d"
  },
  "dependencies": {
    "@emotion/cache": "^11.13.1",
    "@emotion/react": "^11.13.0",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^6.1.1",
    "@mui/material": "^6.1.1",
    "@mui/material-nextjs": "^6.1.1",
    "@mui/system": "^6.1.1",
    "@mui/x-charts": "^7.18.0",
    "@mui/x-data-grid": "^7.18.0",
    "@mui/x-data-grid-pro": "^7.18.0",
    "@mui/x-date-pickers": "^7.18.0",
    "@mui/x-date-pickers-pro": "^7.18.0",
    "@mui/x-tree-view": "^7.18.0",
    "@nestjs-modules/ioredis": "^2.0.2",
    "@nestjs/common": "^10.4.1",
    "@nestjs/core": "^10.4.1",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/serve-static": "^4.0.2",
    "@nestjs/swagger": "^7.4.2",
    "@prisma/client": "5.19.1",
    "@react-spring/web": "^9.7.4",
    "babel-loader": "^9.2.1",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.5",
    "ejs": "^3.1.10",
    "fs-extra": "^11.2.0",
    "helmet": "^7.1.0",
    "ioredis": "^5.4.1",
    "next": "^14.2.10",
    "next-pwa": "^5.6.0",
    "nodemailer": "^6.9.15",
    "prisma": "^5.19.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "tree-kill": "^1.2.2"
  },
  "devDependencies": {
    "@babel/core": "^7.12.0",
    "@eslint/js": "^9.10.0",
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^16.0.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/bcrypt": "^5.0.2",
    "@types/ejs": "^3.1.5",
    "@types/express": "^4.17.17",
    "@types/fs-extra": "^11.0.4",
    "@types/jest": "^29.5.13",
    "@types/node": "^20",
    "@types/nodemailer": "^6.4.16",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.5.0",
    "@typescript-eslint/parser": "^8.5.0",
    "autoprefixer": "^10.4.20",
    "chokidar": "^3.5.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "eslint": "^8",
    "eslint-config-next": "^14.2.11",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-jsx-a11y": "^6.10.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react": "^7.36.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-unused-imports": "^4.1.4",
    "globals": "^15.9.0",
    "jest": "^29.7.0",
    "nodemon": "^3.1.4",
    "postcss": "^8.4.47",
    "prettier": "^3.3.3",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "tsconfig-paths": "^4.2.0",
    "typescript": "5.4.3",
    "typescript-eslint": "^8.5.0",
    "webpack": "^5.94.0"
  }
}

=== End of File: package.json ===

=== Start of File: src/app.controller.ts ===
// src/app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';

@ApiTags('Hello')
@Controller()
export class AppController {
  @Get('hello')
  getHello() {
    return { message: 'Hello from NestJS API!' };
  }
}

=== End of File: src/app.controller.ts ===

=== Start of File: src/app.middleware.ts ===
import { Injectable, Logger, NestMiddleware } from '@nestjs/common';
import { NextFunction, Request, Response } from 'express';

@Injectable()
export class AppMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction): void {
    const start = Date.now();

    // Log requests
    res.on('finish', () => {
      const responseTime = Date.now() - start;
      const message = `${req.method} ${req.originalUrl} ${res.statusCode} ${
        res.get('Content-Length') || 0
      } - ${responseTime}`;

      // Log the request
      this.logger.log(message);
    });

    // Loosen CSP for Swagger routes
    if (
      req.path.startsWith('/swagger') ||
      req.path.startsWith('/favicon.ico')
    ) {
      res.setHeader(
        'Content-Security-Policy',
        "default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;",
      );
    }

    next();
  }
}

=== End of File: src/app.middleware.ts ===

=== Start of File: src/app.module.ts ===
// src/app.module.ts
import { join } from 'path';
import { Module } from '@nestjs/common';
import { ServeStaticModule } from '@nestjs/serve-static';
import { JwtModule } from '@nestjs/jwt';
import { AuthModule } from './auth/auth.module';
import { SseModule } from './sse/sse.module';
import { SystemModule } from './system/system.module';
import { Algorithm } from 'jsonwebtoken';

import { AppController } from './app.controller';
import { JWT_ALGORITHM, JWT_PRIVATE_KEY, JWT_SECRET } from './config/config.env';

@Module({
  imports: [
    // Configure ServeStaticModule to serve the Next.js /public folder
    ServeStaticModule.forRoot({
      rootPath: join(__dirname, '..', 'public'),
      serveRoot: '/public',
    }),
    JwtModule.register({
      secret: JWT_SECRET,
      privateKey: JWT_PRIVATE_KEY,
      signOptions: {
        algorithm: (JWT_ALGORITHM || 'HS256') as Algorithm,
      },
      verifyOptions: {
        algorithms: ([JWT_ALGORITHM || 'HS256']) as Algorithm[],
      },
    }),
    AuthModule,
    SystemModule,
    SseModule,
  ],  
  controllers: [AppController],
  providers: [],
})
export class AppModule {}

=== End of File: src/app.module.ts ===

=== Start of File: src/app.service.ts ===
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

=== End of File: src/app.service.ts ===

=== Start of File: src/main.ts ===
// src/main.ts
import 'reflect-metadata';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { NextFunction, Request, Response } from 'express';
import Next from 'next';

import { AppModule } from './app.module';
import configApp from './config/config.app';
import configSecurityPolicy from './config/config.security';
import configSwagger from './config/config.swagger';
import * as nextConfig from '../next.config.js';
import { HYBRID_ENV, NODE_ENV } from './config/config.env';

// Since the default is true, we can disable the hybrid environment by passing the --no-hybrid flag
const noHybrid = process.argv.includes('--no-hybrid');

// Sanity check on arguments
if (process.argv.length > 2 && !process.argv.includes('--no-hybrid')) {
  console.error('Invalid argument. Use --no-hybrid to disable the hybrid environment.');
  process.exit(1);
}

NestFactory.create<NestExpressApplication>(AppModule).then(async (app) => {
  // Enable the hybrid environment and run Next.js as middleware (defaults to true)
  if (!noHybrid && HYBRID_ENV) {
    const dev = NODE_ENV !== 'production';
    const nextApp = Next({ dev, conf: nextConfig, dir: './' });
    const handle = nextApp.getRequestHandler();
    await nextApp.prepare();

    // Set global prefix for API routes
    app.setGlobalPrefix('api');

    // Middleware to handle Next.js routing
    app.use((req: Request, res: Response, next: NextFunction) => {
      if (req.url.startsWith('/api') || req.url.startsWith('/swagger') || req.url.startsWith('/css')) {
        return next();
      }
      return handle(req, res);
    });
  }

  // Config Security Policy
  configSecurityPolicy(app);

  // Config App
  const listen = configApp(app);

  // Config Swagger
  configSwagger(app);

  // Listen for connections
  listen().then(() => {
    console.log(`> Ready on http://localhost:3000`);
  });
});

=== End of File: src/main.ts ===

=== Start of File: src/user/user.module.ts ===
import { Module } from '@nestjs/common';

@Module({})
export class UserModule {}

=== End of File: src/user/user.module.ts ===

=== Start of File: src/user/user.service.ts ===
import { Injectable } from '@nestjs/common';
import { User } from '@prisma/client';

import { PrismaService } from '../system/services/prisma/prisma.service';

@Injectable()
export class UserService {
  constructor(private prisma: PrismaService) {}

  async create(data: {
    email: string;
    password: string;
    name: string;
  }): Promise<User> {
    return this.prisma.user.create({
      data,
    });
  }

  async delete(id: string) {
    return this.prisma.user.delete({
      where: {
        id,
      },
    });
  }

  async findById(id: string) {
    return this.prisma.user.findUnique({
      where: {
        id,
      },
    });
  }

  async findByEmail(email: string) {
    return this.prisma.user.findUnique({
      where: {
        email,
      },
    });
  }

  async update(id: string, data: Partial<User>) {
    return this.prisma.user.update({
      where: {
        id,
      },
      data,
    });
  }
}

=== End of File: src/user/user.service.ts ===

=== Start of File: start-hybrid.js ===
/**
 * Hybrid Development Server
 *
 * Overview:
 * - Watches the './src' directory for any file changes using 'chokidar'.
 * - On detecting a change:
 *   - Compiles TypeScript files using 'tsc' with the 'tsconfig.server.json' configuration, outputting to the '.nest' directory.
 *   - Restarts the Node.js server by running the compiled JavaScript files.
 * - Manages child processes to ensure only one instance of the server runs at a time.
 * - Handles graceful shutdown on 'Ctrl+C' or 'SIGINT', ensuring all child processes are terminated.
 * - Prevents multiple shutdowns using a closure to manage the shutdown state.
 * - Uses 'readline' to capture keypress events and override default terminal behavior.
 *
 * Key Features:
 * - **File Watching**: Monitors source files for changes and triggers recompilation and restart.
 * - **Process Management**: Keeps track of spawned processes and ensures clean termination.
 * - **Graceful Shutdown**: Listens for interrupt signals to perform a controlled shutdown.
 * - **Cross-Platform Compatibility**: Uses polling in 'chokidar' for better support on various file systems and environments.
 *
 * Usage:
 * - Run this script during development to automatically rebuild and restart your server when you make changes to the source code.
 * - Customize the paths and commands if your project structure differs.
 *
 * Dependencies:
 * - **chokidar**: For efficient file system watching.
 * - **child_process.spawn**: To execute shell commands for compilation and server start.
 * - **tree-kill**: To terminate processes and their child processes.
 * - **readline**: To handle input from the terminal.
 */

const chokidar = require('chokidar');
const { spawn } = require('child_process');
const kill = require('tree-kill');
const readline = require('readline');

// Array to store all running processes
let processes = [];

// Set to store all active promises
const activePromises = new Set();

// Check if the script is running in watch mode
const watch = process.argv.includes('--watch');

// Sanity check on arguments
if (process.argv.length > 2 && !process.argv.includes('--watch')) {
  console.error('Invalid argument. Use --watch to start the script in watch mode.');
  process.exit(1);
}

// Create a readline interface
readline.emitKeypressEvents(process.stdin);
process.stdin.setRawMode(true);

// Prevent Ctrl+C from sending SIGINT to the process
process.stdin.on('keypress', (str, key) => {
  if (key.ctrl && key.name === 'c') {
    // console.log('Ctrl+C was pressed, but it is disabled.');
    shutdown();
  }
});

// Watch the 'src' directory for changes.
const watcher = (function () {
  if (!watch) {
    return;
  }

  // Initialize watcher.
  const watcher = chokidar.watch('./src', {
    persistent: true,
    ignoreInitial: true,
    usePolling: true,  // Use polling for better cross-platform support, particularly on network file systems or Docker containers
  });

  // Event listeners for when files change
  watcher.on('change', async (path) => {
    console.log(`'${path}' has been changed. Restarting app...`);

    // Kill all running processes
    await stopAllProcesses();

    // Clear out old processes (should be empty after stopAllProcesses anyways)
    processes = [];

    // Start the app again
    startApp();
  });

  watcher.on('error', (error) => console.error(`Watcher error: ${error}`));

  return watcher;
})();

async function startApp() {
  if (process.env.NODE_ENV === 'production') {
    return trackPromise(startProduction());
  } else {
    return trackPromise(startDev());
  }
}

// Start the app
async function startDev() {
  try {
    await compile();
    await startServer()
  } catch (error) {
    console.error('Error during app execution:', error.message);
  }
}

// Start the app
async function startProduction() {
  return new Promise(async (resolve, reject) => {
    try {
      const { code } = await startServer();
      if (code !== 0) {
        console.error(`Process exited with code ${code}. Restarting...`);
        await sleep(1000); // Wait a bit before restarting
        startApp(); // Restart the server
      }
    } catch (error) {
      console.error('Error during app execution:', error.message);
    } finally {
      resolve();
    }
  });
}

// Defines a one-shot shutdown function, using a closure to prevent multiple shutdown calls
const shutdown = (() => {
  // Flag to prevent multiple shutdowns
  let shuttingDown = false;

  return async function () {
    if (shuttingDown) {
      return;
    }
    shuttingDown = true;
    console.log('\nShutting down...');

    // Done with the raw mode
    process.stdin.setRawMode(false); // Let's the user use the terminal again  
    process.stdin.pause(); // Stop reading from stdin

    // Close the watcher if it exists
    watcher?.close();

    // Kill all running processes
    await stopAllProcesses();

    // Wait for all tracked promises to finish before exiting
    await Promise.all(Array.from(activePromises));

    // Check if all processes have been killed
    if (processes.length > 0) {
      console.warn('Unable to kill the following processes:', processes.map((proc) => proc.pid).join(', '));
    }

    // Exit the process
    process.exit();
  }
})();

// Handle SIGINT signal by calling shutdown function
// Note: Ctrl-c is normally handled by the readline interface
process.on('SIGINT', async () => {
  await shutdown();
});

(async function main() {
  // Start the app
  console.log(watch ? 'Watching for file changes...' : 'Starting app...');
  try {
    await trackPromise(startApp())
  } catch (error) {
    console.error('Error starting app:', error.message);
  }
})();
process.stdin.resume(); // Keep the process alive

/*********************************************************************** */
/*  End of control flow, the remaining code contains helper functions    */
/*********************************************************************** */

// Helper function to sleep for a given number of milliseconds
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Helper function to create a generator that sleeps for a given number of milliseconds
async function* asleep(ms, retries = 3) {
  for (let i = 0; i < retries; i++) {
    yield sleep(ms);
  }
}

// Helper function to compile the app
async function compile() {
  return spawnProcess('tsc', ['--project', 'tsconfig.server.json', '--outDir', '.nest']);
}

// Helper function to start the server
async function startServer() {
  return await spawnProcess('node', ['.nest/src/main.js']);
}

// Helper function to stop all running processes
async function stopAllProcesses(signals = ['SIGINT', 'SIGTERM', 'SIGKILL']) {
  // Get the first signal to use
  const signal = signals.shift();

  // Attempt to shutdown all processes using this signal
  await signalAllProcesses(signal);

  // Wait for all processes to exit, this is a retry mechanism
  for await (const result of asleep(100, 5)) {
    if (processes.length === 0)
      break;
  }

  // If there are still processes running, try the next signal
  if (processes.length > 0 && signals.length > 0) {
    await stopAllProcesses(signals);
  }
}

// Helper function to send a signal to all running processes
async function signalAllProcesses(signal) {
  // New processes array with only the processes that are still running
  processes = processes.filter((proc) => !proc.killed || proc.exitCode === null);

  if (processes.length === 0) {
    return;
  }

  await Promise.all(
    processes.map((childProcess) =>
      new Promise((resolve) => {
        kill(childProcess.pid, signal, (err) => {
          if (err) {
            console.error(`Error force killing process ${childProcess.pid}:`, err);
          }
          resolve(true);
        });
      })
    )
  );
}

// Helper function to track promises
function trackPromise(promise) {
  if (!promise || typeof promise.finally !== 'function') {
    throw new Error('trackPromise expects a Promise as an argument.');
  }
  activePromises.add(promise);
  promise.finally(() => activePromises.delete(promise));
  return promise;
}

// Helper function to spawn a child process
function spawnProcess(command, args, options = {}) {
  return trackPromise(new Promise((resolve, reject) => {
    let childProcess = spawn(command, args, {
      stdio: 'inherit',
      ...options,
    });
    processes.push(childProcess);

    childProcess.on('close', (code, signal) => {
      // Remove the child process from the list of running processes
      processes = processes.filter((p) => p !== childProcess);
      resolve({ code, signal });
    });

    childProcess.on('error', (err) => {
      reject(err);
    });
  }));
}



=== End of File: start-hybrid.js ===

=== Start of File: tsconfig.build.json ===
{
  "extends": "./tsconfig.server.json",
  "compilerOptions": {
    "outDir": ".nest",
    "module": "CommonJS",
    "moduleResolution": "node",
    "declaration": false,
    "noEmit": false,
    "removeComments": true
  },
  "include": [
    "src/**/*"
  ],    
  "exclude": [
    "node_modules",
    "test",
    "**/*spec.ts",
    "**/*.test.ts",
    ".next",
    ".nest",
    "app"
  ]
}
=== End of File: tsconfig.build.json ===

=== Start of File: tsconfig.json ===
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "forceConsistentCasingInFileNames": true,
    "jsx": "preserve",
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "allowSyntheticDefaultImports": true,
    "useDefineForClassFields": false,
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

=== End of File: tsconfig.json ===

=== Start of File: tsconfig.server.json ===
{
  "compilerOptions": {
    "module": "CommonJS",
    "moduleResolution": "node",
    "noEmit": false,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": false,
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    ".nest",
    ".next"
  ]
}
=== End of File: tsconfig.server.json ===
